"""
AI-powered interpretation of hexagrams using OpenAI and DeepSeek APIs.
Includes caching and error handling to optimize API usage.
"""

import os
import logging
import requests
import json
import time
import hashlib
from typing import Optional, List, Dict, Tuple, Any
from openai import OpenAI
from openai.types.chat import ChatCompletion
from dotenv import load_dotenv
import functools
from datetime import datetime, timedelta

from models.schemas import Hexagram, Line

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("ai_interpretation.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("ai_interpretation")

# Load environment variables
load_dotenv()
OPENAI_API_KEY = os.getenv("OpenAI_API_KEY")
DEEPSEEK_API_KEY = os.getenv("DeepSeek_API_KEY")

# Check if API keys are available
if not OPENAI_API_KEY:
    logger.warning("OpenAI API key not found. OpenAI interpretations will not work.")
if not DEEPSEEK_API_KEY:
    logger.warning("DeepSeek API key not found. DeepSeek interpretations will not work.")

# Initialize clients
client = None
if OPENAI_API_KEY:
    try:
        client = OpenAI(api_key=OPENAI_API_KEY)
        logger.info("OpenAI client initialized successfully")
    except Exception as e:
        logger.error(f"Failed to initialize OpenAI client: {str(e)}")

DEEPSEEK_API_BASE_URL = "https://api.deepseek.com"

# Simple in-memory cache for API responses
# Format: {hash: (timestamp, result)}
interpretation_cache: Dict[str, Tuple[float, str]] = {}
CACHE_EXPIRY = 60 * 60 * 24  # 24 hours in seconds

def create_cache_key(question: str, hexagram_number: int, changed_number: Optional[int] = None, ai_provider: str = "openai") -> str:
    """
    Create a unique cache key for the interpretation request.
    
    Args:
        question: The question asked
        hexagram_number: The primary hexagram number
        changed_number: The changed hexagram number (if any)
        ai_provider: The AI provider used
        
    Returns:
        A unique hash string to use as cache key
    """
    # Create a string that uniquely identifies this interpretation request
    key_str = f"{question}|{hexagram_number}|{changed_number or 0}|{ai_provider}"
    # Create a hash of this string to use as the cache key
    return hashlib.md5(key_str.encode('utf-8')).hexdigest()

def get_from_cache(cache_key: str) -> Optional[str]:
    """
    Try to get a cached interpretation.
    
    Args:
        cache_key: The cache key to look up
        
    Returns:
        The cached interpretation if it exists and is not expired, None otherwise
    """
    if cache_key in interpretation_cache:
        timestamp, result = interpretation_cache[cache_key]
        if time.time() - timestamp < CACHE_EXPIRY:
            logger.info(f"Cache hit for key {cache_key[:8]}...")
            return result
        else:
            # Remove expired cache entry
            del interpretation_cache[cache_key]
            logger.info(f"Cache expired for key {cache_key[:8]}...")
    return None

def store_in_cache(cache_key: str, result: str) -> None:
    """
    Store an interpretation in the cache.
    
    Args:
        cache_key: The cache key
        result: The interpretation to cache
    """
    interpretation_cache[cache_key] = (time.time(), result)
    logger.info(f"Stored in cache: key {cache_key[:8]}...")
    
    # Simple cache size management - if cache gets too big, remove oldest entries
    if len(interpretation_cache) > 100:  # Limit cache to 100 entries
        oldest_key = min(interpretation_cache.items(), key=lambda x: x[1][0])[0]
        del interpretation_cache[oldest_key]
        logger.info(f"Cache full, removed oldest entry: {oldest_key[:8]}")

def get_ai_interpretation(
    question: str,
    original_hexagram: Hexagram,
    changed_hexagram: Optional[Hexagram],
    lines: List[Line],
    user_context: Optional[Dict] = None
) -> str:
    """
    Generate an AI-powered interpretation of the divination result.
    
    Args:
        question: The original question asked
        original_hexagram: The primary hexagram
        changed_hexagram: The changed hexagram (if any)
        lines: The six lines with changing information
        user_context: Optional additional context about the user
        
    Returns:
        AI-generated interpretation string
    """
    # Check if OpenAI is available
    if not OPENAI_API_KEY or not client:
        logger.error("OpenAI API key not configured or client initialization failed")
        return "无法连接到 OpenAI 服务。请检查 API 密钥配置或联系管理员。"
    
    # Create cache key
    changed_number = changed_hexagram.number if changed_hexagram else None
    cache_key = create_cache_key(question, original_hexagram.number, changed_number, "openai")
    
    # Try to get from cache
    cached_result = get_from_cache(cache_key)
    if cached_result:
        return cached_result
    
    try:
        # Format detailed hexagram information using helper function
        hexagram_info = format_hexagram_details(original_hexagram, lines)
        
        # Include changed hexagram info if available
        changed_info = ""
        if changed_hexagram:
            changed_info = format_hexagram_details(changed_hexagram, lines, True)
        
        # Construct the prompt for AI
        prompt = f"""
        作为一位精通易经占卜的专家，请基于以下信息为用户提供详细、准确的占卜解读：
        
        问题: {question}
        
        {hexagram_info}
        {changed_info}
        
        爻象信息:
        {chr(10).join(lines_info)}
        
        请提供以下方面的详细解读:
        1. 总体解释 - 结合卦象与问题的核心回答
        2. 详细分析 - 分析卦象的具体含义
        3. 具体领域解读 - 在事业、财富、人际关系等方面的具体指引
        4. 变化趋势 (如果有变卦) - 分析情况将如何发展
        5. 实用建议 - 给予切实可行的行动建议
        
        解读应当深入但通俗易懂，避免过于学术化的术语，保持尊重用户但不过度夸大卦象暗示，确保准确传达易经智慧。
        将解读分成清晰的段落，使用emoji增加可读性，但保持专业性。
        """
        
        # Add user context if available
        if user_context:
            context_str = "\n用户背景信息:\n"
            for key, value in user_context.items():
                context_str += f"- {key}: {value}\n"
            prompt += context_str
              # Call OpenAI API with retry mechanism
        max_retries = 3
        retry_delay = 2  # seconds
        
        for attempt in range(max_retries):
            try:
                start_time = time.time()
                response = client.chat.completions.create(
                    model="gpt-4o",
                    messages=[
                        {"role": "system", "content": "你是一位精通易经的占卜大师，有着深厚的易经知识和多年占卜经验，能够将易经智慧应用到现代问题中。"},
                        {"role": "user", "content": prompt}
                    ],
                    temperature=0.7,
                    max_tokens=2000
                )
                
                elapsed_time = time.time() - start_time
                logger.info(f"OpenAI API call successful in {elapsed_time:.2f}s")
                
                # Extract the AI's interpretation
                result = response.choices[0].message.content
                
                # Cache the result
                store_in_cache(cache_key, result)
                
                return result
                
            except Exception as e:
                logger.error(f"OpenAI API error (attempt {attempt+1}/{max_retries}): {str(e)}")
                if attempt < max_retries - 1:
                    logger.info(f"Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                    retry_delay *= 2  # Exponential backoff
                else:
                    # All retries failed
                    error_msg = f"AI解读生成失败，已尝试 {max_retries} 次。错误信息: {str(e)}"
                    return error_msg
    
    except Exception as e:
        logger.error(f"Unexpected error in AI interpretation: {str(e)}")
        return "AI解读生成失败，发生未预期的错误。请稍后重试。"

def get_deepseek_interpretation(
    question: str,
    original_hexagram: Hexagram,
    changed_hexagram: Optional[Hexagram],
    lines: List[Line],
    user_context: Optional[Dict] = None
) -> str:
    """
    Generate a DeepSeek-powered interpretation of the divination result.
    
    Args:
        question: The original question asked
        original_hexagram: The primary hexagram
        changed_hexagram: The changed hexagram (if any)
        lines: The six lines with changing information
        user_context: Optional additional context about the user
        
    Returns:
        DeepSeek-generated interpretation string
    """
    # Check if DeepSeek API key is available
    if not DEEPSEEK_API_KEY:
        logger.error("DeepSeek API key not configured")
        return "无法连接到 DeepSeek 服务。请检查 API 密钥配置或联系管理员。"
    
    # Create cache key
    changed_number = changed_hexagram.number if changed_hexagram else None
    cache_key = create_cache_key(question, original_hexagram.number, changed_number, "deepseek")
    
    # Try to get from cache
    cached_result = get_from_cache(cache_key)
    if cached_result:
        return cached_result
          try:
        # Format detailed hexagram information using helper function
        hexagram_info = format_hexagram_details(original_hexagram, lines)
        
        # Include changed hexagram info if available
        changed_info = ""
        if changed_hexagram:
            changed_info = format_hexagram_details(changed_hexagram, lines, True)
        
        # Construct the prompt for AI
        prompt = f"""
        作为一位精通易经占卜的专家，请基于以下信息为用户提供详细、准确的占卜解读：
        
        问题: {question}
        
        {hexagram_info}
        {changed_info}
        
        爻象信息:
        {chr(10).join(lines_info)}
        
        请提供以下方面的详细解读:
        1. 总体解释 - 结合卦象与问题的核心回答
        2. 详细分析 - 分析卦象的具体含义
        3. 具体领域解读 - 在事业、财富、人际关系等方面的具体指引
        4. 变化趋势 (如果有变卦) - 分析情况将如何发展
        5. 实用建议 - 给予切实可行的行动建议
        
        解读应当深入但通俗易懂，避免过于学术化的术语，保持尊重用户但不过度夸大卦象暗示，确保准确传达易经智慧。
        将解读分成清晰的段落，使用emoji增加可读性，但保持专业性。
        """
        
        # Add user context if available
        if user_context:
            context_str = "\n用户背景信息:\n"
            for key, value in user_context.items():
                context_str += f"- {key}: {value}\n"
            prompt += context_str
          # Make API request to DeepSeek API with retry mechanism
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {DEEPSEEK_API_KEY}"
        }
        
        payload = {
            "model": "deepseek-chat",
            "messages": [
                {"role": "system", "content": "你是一位精通易经的占卜大师，有着深厚的易经知识和多年占卜经验，能够将易经智慧应用到现代问题中。"},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.7,
            "max_tokens": 2000
        }
        
        max_retries = 3
        retry_delay = 2  # seconds
        
        for attempt in range(max_retries):
            try:
                start_time = time.time()
                response = requests.post(
                    f"{DEEPSEEK_API_BASE_URL}/v1/chat/completions", 
                    headers=headers, 
                    json=payload,
                    timeout=30  # Add timeout to avoid hanging requests
                )
                
                elapsed_time = time.time() - start_time
                logger.info(f"DeepSeek API call attempt {attempt+1}, status code: {response.status_code}, time: {elapsed_time:.2f}s")
                
                if response.status_code == 200:
                    result = response.json()
                    interpretation = result["choices"][0]["message"]["content"]
                    
                    # Cache the successful result
                    store_in_cache(cache_key, interpretation)
                    
                    return interpretation
                elif response.status_code == 429:  # Rate limit
                    logger.warning(f"DeepSeek API rate limit hit, retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                    retry_delay *= 2  # Exponential backoff
                elif response.status_code >= 500:  # Server error
                    if attempt < max_retries - 1:
                        logger.warning(f"DeepSeek API server error, retrying in {retry_delay} seconds...")
                        time.sleep(retry_delay)
                        retry_delay *= 2  # Exponential backoff
                    else:
                        logger.error(f"DeepSeek API server error after {max_retries} attempts: {response.text}")
                        return f"DeepSeek服务器暂时不可用，请稍后重试。(状态码: {response.status_code})"
                else:  # Other errors
                    logger.error(f"DeepSeek API error: {response.status_code} - {response.text}")
                    return f"DeepSeek解读生成失败: {response.status_code} - {response.reason}"
            
            except requests.Timeout:
                logger.error(f"DeepSeek API timeout on attempt {attempt+1}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    retry_delay *= 2
                else:
                    return "DeepSeek API请求超时，请稍后重试。"
                    
            except requests.RequestException as e:
                logger.error(f"DeepSeek API request error on attempt {attempt+1}: {str(e)}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    retry_delay *= 2
                else:
                    return f"DeepSeek API请求错误: {str(e)}"
    except Exception as e:
        logger.error(f"Unexpected error in DeepSeek interpretation: {str(e)}")
        return f"DeepSeek解读生成失败，发生未预期的错误: {str(e)}"


def format_hexagram_details(hexagram: Hexagram, lines: List[Line], is_changed_hexagram: bool = False) -> str:
    """
    Format detailed information about a hexagram, including its properties, 
    kingwen text, image text, and line information.
    
    Args:
        hexagram: The hexagram to format
        lines: The six lines of the hexagram
        is_changed_hexagram: Whether this is the changed hexagram
        
    Returns:
        A formatted string with detailed hexagram information
    """
    title = "变卦" if is_changed_hexagram else "本卦"
    
    # Basic hexagram information
    info = f"""
    {title}: {hexagram.chineseName} ({hexagram.name}) - 第{hexagram.number}卦
    卦象: {hexagram.symbol}
    """
    
    # Add kingwen text if available
    if hasattr(hexagram, 'kingWen') and hexagram.kingWen:
        info += f"卦辞: {hexagram.kingWen.text}\n"
        if hexagram.kingWen.explanation:
            info += f"卦辞解释: {hexagram.kingWen.explanation}\n"
    
    # Add image text if available
    if hasattr(hexagram, 'image') and hexagram.image:
        if hexagram.image.text:
            info += f"象辞: {hexagram.image.text}\n"
        if hexagram.image.explanation:
            info += f"象辞解释: {hexagram.image.explanation}\n"
    
    # For changed hexagram, we don't need to include line details
    if is_changed_hexagram:
        changing_positions = [line.position for line in lines if line.changing]
        info += f"变爻: 第 {', '.join(map(str, changing_positions))} 爻\n"
        return info
        
    # Add detailed line information for the original hexagram
    lines_info = []
    for line in lines:
        changing_status = "（变爻）" if line.changing else ""
        line_type = "阳爻" if line.type == "yang" else "阴爻"
        line_info = f"第{line.position}爻: {line_type}{changing_status}"
        
        if hasattr(line, 'text') and line.text:
            line_info += f" - 爻辞: {line.text}"
        
        if hasattr(line, 'explanation') and line.explanation:
            line_info += f" - 爻辞解释: {line.explanation}"
            
        if hasattr(line, 'image') and line.image:
            if hasattr(line.image, 'text') and line.image.text:
                line_info += f" - 象辞: {line.image.text}"
            if hasattr(line.image, 'explanation') and line.image.explanation:
                line_info += f" - 象辞解释: {line.image.explanation}"
                
        lines_info.append(line_info)
    
    if lines_info:
        info += "\n爻象信息:\n" + "\n".join(lines_info)
        
    return info


async def test_ai_connections() -> Dict[str, bool]:
    """
    Test connections to AI providers.
    
    Returns:
        Dictionary with provider names as keys and connection status as values
    """
    results = {
        "openai": False,
        "deepseek": False
    }
    
    # Test OpenAI connection
    if OPENAI_API_KEY and client:
        try:
            # Simple test prompt
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "user", "content": "简单测试 - 请回复'连接正常'"}
                ],
                max_tokens=10,
                timeout=5
            )
            if response and response.choices and response.choices[0].message.content:
                results["openai"] = True
                logger.info("OpenAI connection test successful")
        except Exception as e:
            logger.error(f"OpenAI connection test failed: {str(e)}")
    else:
        logger.warning("OpenAI API key not configured, skipping connection test")
    
    # Test DeepSeek connection
    if DEEPSEEK_API_KEY:
        try:
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {DEEPSEEK_API_KEY}"
            }
            
            payload = {
                "model": "deepseek-chat",
                "messages": [
                    {"role": "user", "content": "简单测试 - 请回复'连接正常'"}
                ],
                "max_tokens": 10
            }
            
            response = requests.post(
                f"{DEEPSEEK_API_BASE_URL}/v1/chat/completions", 
                headers=headers, 
                json=payload,
                timeout=5
            )
            
            if response.status_code == 200:
                results["deepseek"] = True
                logger.info("DeepSeek connection test successful")
            else:
                logger.error(f"DeepSeek connection test failed: {response.status_code} - {response.text}")
        except Exception as e:
            logger.error(f"DeepSeek connection test failed: {str(e)}")
    else:
        logger.warning("DeepSeek API key not configured, skipping connection test")
    
    return results
